//***********************************************************************
// program to analyze bands and report some information on changing
//									 
//***********************************************************************
// version 
// 1.0.0	06/07/2018	Rémi Saint-Amant	Creation from CloudCleaner


//-of VRT --config GDAL_CACHEMAX 4096 -stats -overview {2,4,8,16} -overwrite "D:\Travaux\CloudCleaner\Model\RF_v2" "D:\Travaux\MergeImage\input\subset\ref.vrt" "D:\Travaux\MergeImage\input\subset\2015-2016-2017_21.vrt"


#include "stdafx.h"
#include <float.h>
#include <math.h>
#include <array>
#include <utility>
#include <iostream>
#include <bitset>
#include <boost/dynamic_bitset.hpp>

#include "CloudCleanerI.h"
#include "Basic/UtilTime.h"
#include "Basic/UtilMath.h"
#include "Basic/OpenMP.h"
#include "Geomatic/GDALBasic.h"
#include "Geomatic/LandsatDataset.h"




#pragma warning(disable: 4275 4251)
#include "gdal_priv.h"



using namespace std;
using namespace WBSF;
using namespace WBSF::Landsat;



static const char* version = "1.0.0";
static const int NB_THREAD_PROCESS = 2;
static const __int16 NOT_TRIGGED_CODE = (__int16)::GetDefaultNoData(GDT_Int16);
static const CLandsatPixel NO_PIXEL;
const char* CCloudCleanerIOption::DEBUG_NAME[NB_DBUG] = { "_ID", "_B1f", "_TCBf", "_ZSWf", "_nbScenes", "_fill" };


std::string CCloudCleanerI::GetDescription()
{
	return  std::string("CloudCleanerI version ") + version + " (" + _T(__DATE__) + ")\n";
}


CCloudCleanerIOption::CCloudCleanerIOption() :CBaseOptions(false)
{
	m_nbPixel = 0;
	m_nbPixelDT = 0;
	m_scenesSize = Landsat::SCENES_SIZE;
	m_bDebug = false;
	m_bOutputDT = false;
	m_B1threshold = { -175, -60 };
	m_TCBthreshold = { 600, 200 };
	m_ZSWthreshold = { 500, 160 };
	m_doubleTrigger = 5;
	m_bBackup = false;
	m_maxScene = 3;
	m_buffer = 1;
	m_bufferEx = 2;

	m_appDescription = "This software mask cloud by updating JD band of LANDSAT images (composed of " + to_string(SCENES_SIZE) + " bands) with a random forest model (from Ranger)";

	//AddOption("-CPU");
	AddOption("-multi");
	AddOption("-?");
	AddOption("-??");
	AddOption("-???");

	static const COptionDef OPTIONS[] =
	{
		{ "-Thres", 4, "type B1 TCB ZSW", false, "Set trigger threshold for B1, TCB and ZSW to set pixel as suspect and execute random forest. Type is 1 for primary threshold and 2 for secondary threshod. -175 600 500 for primary and -60 200 160 for secondary." },
		{ "-Buffer", 1, "nbPixel", false, "Set all pixels arround cloud pixels as cloud. 1 by default." },
		{ "-BufferEx", 1, "nbPixel", false, "Set suspicious pixels arround cloud pixels as cloud. 2 by default." },
		{ "-Backup", 0, "", false, "Backup JD layer before overwrite it. If a backup already exist, it will be overwrite." },
		{ "-DoubleTrigger", 1, "nbPixel", false, "Set the buffer size for secondary suspicious pixel. 5 by default" },
		//		{ "-MaxScene", 1, "nbScenes", false, "Use to limit the number of scenes read in the reference images (around the working scene) to find and fill clouds. 3 by default (from ws -3 to ws + 3)." },
				//{ "-OutputCode", 0, "", false, "Output random forest result code." },
				//{ "-Debug",0,"",false,"Output debug information."},
				{ "Model", 0, "", false, "Random forest cloud model file path." },
				{ "RefFile", 0, "", false, "Input LANDSAT scenes reference image file path for previous and next scene." },
				{ "Image list", 0, "", false, "LANDSAT scene to update JD mask file path. VRT only." }
	};

	for (int i = 0; i < sizeof(OPTIONS) / sizeof(COptionDef); i++)
		AddOption(OPTIONS[i]);

	static const CIOFileInfoDef IO_FILE_INFO[] =
	{
		{ "Input Model", "Model", "", "", "", "Random forest model file generated by Ranger." },
		{ "LANDSAT Image", "src1file", "NbScenes", "ScenesSize(9)", "B1: Landsat band 1|B2: Landsat band 2|B3: Landsat band 3|B4: Landsat band 4|B5: Landsat band 5|B6: Landsat band 6|B7: Landsat band 7|QA: Image quality|JD: Date(Julian day 1970)|... for each scene" },
		{ "Image to update JD", "file", "Nb scenes processed", "ScenesSize(9)", "B1: Landsat band 1|B2: Landsat band 2|B3: Landsat band 3|B4: Landsat band 4|B5: Landsat band 5|B6: Landsat band 6|B7: Landsat band 7|QA: Image quality|JD: Date(Julian day 1970)" },
		//{ "Optional Code Image", "dstfile_code","Nb scenes processed","1","random forest result"},
		//{ "Optional Debug Image", "dstfile_debug", "Nb scenes processed", "6", "Bit fields [secondary(8)|ZSW(4)|TCB(2)|B1(1)]|Cloud trigged (B1)|Shadow trigged (TCB)|Haze trigged (Z-Score Water)|Nb scene|scene selected to fill cloud (relative to the filled scene)"}

	};

	for (int i = 0; i < sizeof(IO_FILE_INFO) / sizeof(CIOFileInfoDef); i++)
		AddIOFileInfo(IO_FILE_INFO[i]);

}

ERMsg CCloudCleanerIOption::ProcessOption(int& i, int argc, char* argv[])
{
	ERMsg msg;


	//if (IsEqual(argv[i], "-B1"))
	//{
	//	m_B1threshold[0] = atof(argv[++i]);
	//}
	//else if (IsEqual(argv[i], "-TCB"))
	//{
	//	m_TCBthreshold[0] = atof(argv[++i]);
	//}

	if (IsEqual(argv[i], "-Thres"))
	{
		size_t type = atoi(argv[++i]) - 1;
		if (type < 2)
		{
			m_B1threshold[type] = atoi(argv[++i]);
			m_TCBthreshold[type] = atoi(argv[++i]);
			m_ZSWthreshold[type] = atoi(argv[++i]);
		}
		else
		{
			msg.ajoute("invalide threshold type. type must be 1 or 2");
		}
	}
	else if (IsEqual(argv[i], "-Buffer"))
	{
		m_buffer = atoi(argv[++i]);

	}
	else if (IsEqual(argv[i], "-BufferEx"))
	{
		m_bufferEx = atoi(argv[++i]);
	}
	else if (IsEqual(argv[i], "-DoubleTrigger"))
	{
		m_doubleTrigger = atoi(argv[++i]);
	}
	else if (IsEqual(argv[i], "-Backup"))
	{
		m_bBackup = true;
	}
	else if (IsEqual(argv[i], "-MaxScene"))
	{
		m_maxScene = atoi(argv[++i]);
	}
	else
	{
		//Look to see if it's a know base option
		msg = CBaseOptions::ProcessOption(i, argc, argv);
	}

	return msg;
}

ERMsg CCloudCleanerIOption::ParseOption(int argc, char* argv[])
{
	ERMsg msg = CBaseOptions::ParseOption(argc, argv);

	ASSERT(NB_FILE_PATH == 3);
	if (msg && m_filesPath.size() != NB_FILE_PATH)
	{
		msg.ajoute("ERROR: Invalid argument line. 3 files are needed: the random forest models, the LANDSAT reference images series (annual) and LANDSAT image list (as VRT) to update JD mask.");
		msg.ajoute("Argument found: ");
		for (size_t i = 0; i < m_filesPath.size(); i++)
			msg.ajoute("   " + to_string(i + 1) + "- " + m_filesPath[i]);
	}

	if (m_outputType == GDT_Unknown)
		m_outputType = GDT_Int16;

	//if (m_outputType != GDT_Int16 && m_outputType != GDT_Int32)
		//msg.ajoute("Invalid -ot option. Only GDT_Int16 or GDT_Int32 are supported");

	//if (m_maxScene < 1)
		//msg.ajoute("Invalid -MaxScene. -FillMaxScene must be greater than 1.");

	return msg;
}


//***********************************************************************


ERMsg CCloudCleanerI::ReadModel(std::string filePath, int CPU, ForestPtr& forest)
{
	ERMsg msg;

	TreeType treetype = GetTreeType(filePath);

	try
	{
		forest.reset(CreateForest(treetype));
		forest->init_predict(0, CPU, false, DEFAULT_PREDICTIONTYPE);
		forest->loadFromFile(filePath);
		cout << "Forest name:                       " << GetFileTitle(GetFileTitle(filePath)) << std::endl;
		cout << "Forest type:                       " << GetTreeTypeStr(treetype) << std::endl;
		cout << "Number of trees:                   " << forest->getNumTrees() << std::endl;
		cout << "Dependent variable column:         " << forest->getDependentVarId() + 1 << std::endl;
		cout << "Number of independent variables:   " << forest->getNumIndependentVariables() << std::endl;
		cout << std::endl;
	}
	catch (std::exception e)
	{
		msg.ajoute(e.what());
	}

	return msg;
}

ERMsg CCloudCleanerI::ReadModel(Forests3& forests)
{
	ERMsg msg;

	CTimer timer(true);

	if (!m_options.m_bQuiet)
		cout << "Read forest..." << endl;

	static const char* EXTRA[3] = { "START","MIDDLE","END" };
	for (size_t f = 0; f < 3; f++)
	{
		string filePath = m_options.m_filesPath[CCloudCleanerIOption::RF_MODEL_FILE_PATH];
		SetFileName(filePath, GetFileTitle(filePath) + "_" + EXTRA[f] + ".classification.forest");
		msg += ReadModel(filePath, m_options.m_bMulti ? m_options.m_CPU : -1, forests[f]);
	}


	timer.Stop();

	if (!m_options.m_bQuiet)
		cout << "Read forest time = " << SecondToDHMS(timer.Elapsed()).c_str() << endl << endl;

	return msg;
}


ERMsg CCloudCleanerI::OpenAll(CLandsatDataset& inputDS, CLandsatDataset& refDS, CGDALDatasetEx& maskDS/*, CGDALDatasetEx& DTCodeDS, CGDALDatasetEx& debugDS*/)
{
	ERMsg msg;



	if (!m_options.m_bQuiet)
		cout << endl << "Open input image..." << endl;

	msg += inputDS.OpenInputImage(m_options.m_filesPath[CCloudCleanerIOption::UPDATE_FILE_PATH], m_options);

	if (!m_options.m_bQuiet)
		cout << endl << "Open reference image..." << endl;


	msg += refDS.OpenInputImage(m_options.m_filesPath[CCloudCleanerIOption::REF_FILE_PATH], m_options);

	if (!msg)
		return msg;

	const char* desc = inputDS->GetDriver()->GetDescription();
	if (strcmp(desc, "VRT") != 0)
		cout << endl << "Only VRT file is accepted for image list..." << endl;

	inputDS.UpdateOption(m_options);

	if (msg && !m_options.m_maskName.empty())
	{
		if (!m_options.m_bQuiet)
			cout << "Open mask image..." << endl;

		msg += maskDS.OpenInputImage(m_options.m_maskName);
	}


	return msg;
}



ERMsg CCloudCleanerI::Execute()
{
	ERMsg msg;

	if (!m_options.m_bQuiet)
	{
		cout << "Update: " << m_options.m_filesPath[CCloudCleanerIOption::UPDATE_FILE_PATH] << endl;
		cout << "Using:  " << m_options.m_filesPath[CCloudCleanerIOption::REF_FILE_PATH] << endl;
		cout << "Using:  " << m_options.m_filesPath[CCloudCleanerIOption::RF_MODEL_FILE_PATH] << endl;

		if (!m_options.m_maskName.empty())
			cout << "Mask:   " << m_options.m_maskName << endl;
	}

	GDALAllRegister();

	Forests3 forests;
	msg += ReadModel(forests);

	if (!msg)
		return msg;

	CLandsatDataset inputDS;
	CLandsatDataset refDS;
	CGDALDatasetEx maskDS;

	//CGDALDatasetEx DTCodeDS;
	//CGDALDatasetEx debugDS;


	msg = OpenAll(inputDS, refDS, maskDS);

	if (msg)
	{
		const std::vector<CTPeriod>& p = inputDS.GetScenePeriod();

		//size_t nbScenes = inputDS.GetNbScenes();
		//size_t sceneSize = inputDS.GetSceneSize();

		/*m_maxScene
			CTPeriod processPeriod = inputDS.GetPeriod();
			processPeriod.Transform(CTM::ANNUAL);
			processPeriod.Begin() -= 1;
			processPeriod.End() += 1;
			processPeriod.Transform(CTM::DAILY);

			m_options.m_period = processPeriod;*/



		if (!m_options.m_bQuiet)
			cout << "Clean clouds of " << inputDS.GetNbScenes() << " scenes" << endl;

		m_options.ResetBar((size_t)inputDS.GetNbScenes());

		//#pragma omp parallel for schedule(static, 1) num_threads(NB_THREAD_PROCESS) if (m_options.m_bMulti)
		for (int z = 0; z < (int)inputDS.GetNbScenes(); z++)
		{
			//CBandsHolderMT bandHolder1(1, m_options.m_memoryLimit, m_options.m_IOCPU, NB_THREAD_PROCESS);
			//CBandsHolderMT bandHolder2(1, m_options.m_memoryLimit, m_options.m_IOCPU, NB_THREAD_PROCESS);
			CBandsHolder bandHolder1(1, m_options.m_memoryLimit, m_options.m_IOCPU);
			CBandsHolder bandHolder2(1, m_options.m_memoryLimit, m_options.m_IOCPU);

			if (maskDS.IsOpen())
			{
				bandHolder1.SetMask(maskDS.GetSingleBandHolder(), m_options.m_maskDataUsed);
				bandHolder2.SetMask(maskDS.GetSingleBandHolder(), m_options.m_maskDataUsed);
			}

			msg += bandHolder1.Load(inputDS, true);//take only this layer
			msg += bandHolder2.Load(refDS, true/*, m_options.m_period*/);
			if (!msg)
				return msg;



			CGeoExtents extents = inputDS.GetInternalExtents(z*SCENES_SIZE);
			CloudBitset suspects1((size_t)extents.m_xSize*extents.m_ySize);

			CloudBitset suspects2;
			if (m_options.m_doubleTrigger > 0)
				suspects2.resize((size_t)extents.m_xSize*extents.m_ySize);

			CloudBitset clouds((size_t)extents.m_xSize*extents.m_ySize);


			vector<pair<int, int>> XYindex = extents.GetBlockList();

			//pass 1 : find suspicious pîxel
			int thread = omp_get_thread_num();

			//data
			//ReadBlock(extents, p[z], bandHolder1[thread], bandHolder2[thread]);
			ReadBlock(extents, p[z], bandHolder1, bandHolder2);

			//allocate process memory and load data
			CLandsatPixelVector  data1;
			//LoadData(z, bandHolder1[thread], data1);
			LoadData(z, bandHolder1, data1);
			LansatData data2;
			//LoadData(bandHolder2[thread], data2);
			LoadData(bandHolder2, data2);

			inputDS.FlushCache();
			refDS.FlushCache();


			GetSuspicious(data1, data2, forests, suspects1, suspects2);
			//cout << "Suspicious1 for scene " << i + 1 << ": " << std::fixed << std::setprecision(2) << (double)suspects1[zz].count() / suspects1[zz].size() * 100.0 << "%" << endl;

			if (!suspects2.empty())
			{
				//cout << "Merge primary and secondary suspicious pixels" << endl;
				CleanSuspect2(extents, suspects1, suspects2);

				//cout << "Suspicious2 for scene " << i + 1 << ": " << std::fixed << std::setprecision(2) << (double)suspects2[zz].count() / suspects2[zz].size() * 100.0 << "%" << endl;
			}


			//pass 2 : find clouds pixel
			GetClouds(data1, data2, forests, suspects1, suspects2, clouds);

			if (clouds.any())
			{
				//pass 3 : set buffer around clouds
				SetBuffer(extents, suspects1, suspects2, clouds);

				//if (!m_options.m_bQuiet)
					//cout << "Clean JD mask ..." << endl;

					//pass 4 : reset or replace clouds
				string JD_file_path = inputDS.GetInternalName(z*SCENES_SIZE + JD);

				if (m_options.m_bBackup)
				{
					string JD_file_path_bak = JD_file_path + ".bak";
					if(!WBSF::FileExists(JD_file_path_bak))
						msg += WBSF::CopyOneFile(JD_file_path, JD_file_path_bak, false);
				}

				GDALDataset* poDataset = (GDALDataset *)GDALOpenEx(JD_file_path.c_str(), GDAL_OF_UPDATE | GDAL_OF_RASTER | GDAL_OF_VERBOSE_ERROR, NULL, NULL, NULL);

				if (poDataset != NULL)
				{
					ASSERT(clouds.size() == poDataset->GetRasterXSize()*poDataset->GetRasterYSize());
					__int16 noData = (__int16)::GetDefaultNoData(GDT_Int16);

					GDALRasterBand *pBand = poDataset->GetRasterBand(1);

					vector<__int16> data(poDataset->GetRasterXSize()*poDataset->GetRasterYSize());
					pBand->RasterIO(GF_Read, 0, 0, poDataset->GetRasterXSize(), poDataset->GetRasterYSize(), &(data[0]), poDataset->GetRasterXSize(), poDataset->GetRasterYSize(), GDT_Int16, 0, 0);

					for (size_t xy = 0; xy < data.size(); xy++)
					{
						if (clouds.test(xy))
							data[xy] = noData;
					}

					pBand->RasterIO(GF_Write, 0, 0, poDataset->GetRasterXSize(), poDataset->GetRasterYSize(), &(data[0]), poDataset->GetRasterXSize(), poDataset->GetRasterYSize(), GDT_Int16, 0, 0);

					GDALClose(poDataset);
				}
				else
				{
					msg.ajoute(CPLGetLastErrorMsg());
				}
			}

			//for (size_t zz = 0; zz < clouds.size(); zz++)
			//cout << "Cloud for scene " << z + 1 << ": " << std::fixed << std::setprecision(2) << (double)clouds.count() / clouds.size() * 100.0 << "%" << endl;

			m_options.m_xx++;
			m_options.UpdateBar();

		}

		//close inputs and outputs
		CloseAll(inputDS, refDS, maskDS);
	}

	return msg;
}


void CCloudCleanerI::ReadBlock(CGeoExtents extents, CTPeriod p, CBandsHolder& bandHolder1, CBandsHolder& bandHolder2)
{
#pragma omp critical(BlockIO)
	{

		m_options.m_timerRead.Start();

		bandHolder1.LoadBlock(extents, p);
		CTPeriod pp = CTPeriod(CTRef(p.Begin().GetYear()-2, FIRST_MONTH, FIRST_DAY), CTRef(p.Begin().GetYear()+2, LAST_MONTH, LAST_DAY));
		bandHolder2.LoadBlock(extents, pp);

		m_options.m_timerRead.Stop();
	}
}


size_t GetPrevious(const CLandsatPixelVector& landsat, int jd)
{
	size_t previous = NOT_INIT;

	int year1 = CBaseOptions::GetTRef(CBaseOptions::JDAY1970, jd).GetYear();
	for (size_t zz = landsat.size() - 1; zz < landsat.size() && previous == NOT_INIT; zz--)
	{

		if (landsat[zz].IsValid() && landsat[zz][JD] < jd)
		{
			int year2 = CBaseOptions::GetTRef(CBaseOptions::JDAY1970, landsat[zz][JD]).GetYear();
			if (year1 != year2)
				previous = zz;
		}

	}

	return previous;
}

size_t GetNext(const CLandsatPixelVector& landsat, int jd)
{
	size_t next = NOT_INIT;

	int year1 = CBaseOptions::GetTRef(CBaseOptions::JDAY1970, jd).GetYear();
	for (size_t zz = 0; zz < landsat.size() && next == NOT_INIT; zz++)
	{
		if (landsat[zz].IsValid() && landsat[zz][JD] > jd)
		{
			int year2 = CBaseOptions::GetTRef(CBaseOptions::JDAY1970, landsat[zz][JD]).GetYear();
			if (year1 != year2)
				next = zz;
		}
	}

	return next;
}
//
//CLandsatPixel GetMedianNBR(CLandsatPixelVector& data)
//{
//	CLandsatPixel output;
//
//	array<vector<pair<__int16, __int16>>, SCENES_SIZE> median;
//	for (size_t z = 0; z < median.size(); z++)
//		median[z].reserve(data.size());
//
//	for (size_t iz = 0; iz < data.size(); iz++)
//	{
//		if (data[iz].IsValid() && !data[iz].IsBlack())
//		{
//			for (size_t z = 0; z < data[iz].size(); z++)
//				median[z].push_back(make_pair(data[iz][z], data[iz][QA])); //data[iz][QA]
//		}
//	}//iz
//
//	if (!median[0].empty())
//	{
//		for (size_t z = 0; z < median.size(); z++)
//			sort(median[z].begin(), median[z].end());
//
//		for (size_t z = 0; z < median.size(); z++)
//		{
//			size_t N1 = (median[z].size() + 1) / 2 - 1;
//			size_t N2 = median[z].size() / 2 + 1 - 1;
//			size_t N = median[z][N1].second < median[z][N2].second ? N1 : N2;
//			ASSERT(N2 == N1 || N2 == N1 + 1);
//
//			output[z] = median[z][N].first;
//		}
//	}
//
//	return output;
//}

size_t get_m(const CLandsatPixel& data1, const CLandsatPixelVector& data2)
{
	size_t m = NOT_INIT;
	size_t z0 = GetPrevious(data2, data1[JD]);
	size_t z2 = GetNext(data2, data1[JD]);

	if (z0 != NOT_INIT && z2 != NOT_INIT)
	{
		m = 1;
	}
	else if (z0 == NOT_INIT && z2 != NOT_INIT)
	{
		m = 0;
	}
	else if (z0 != NOT_INIT && z2 == NOT_INIT)
	{
		m = 2;
	}

	return m;
}

array <CLandsatPixel, 3> GetP(const CLandsatPixel& data1, const CLandsatPixelVector& data2)
{
	array <CLandsatPixel, 3> p;

	size_t z0 = GetPrevious(data2, data1[JD]);
	size_t z2 = GetNext(data2, data1[JD]);

	if (z0 == NOT_INIT && z2 == NOT_INIT)
	{
		p[1] = data1;
	}
	else if (z0 == NOT_INIT)
	{
		p[0] = data1;
		p[1] = data2[z2];
		z2 = GetNext(data2, data2[z2][JD]);
		p[2] = z2 < data2.size() ? data2[z2] : NO_PIXEL;
	}
	else if (z2 == NOT_INIT)
	{
		p[2] = data1;
		p[1] = data2[z0];
		z0 = GetPrevious(data2, data2[z0][JD]);
		p[0] = z0 < data2.size() ? data2[z0] : NO_PIXEL;
	}
	else
	{
		p[1] = data1;
		p[0] = data2[z0];
		p[2] = data2[z2];
	}

	return p;
}

//Get input image reference
void CCloudCleanerI::GetSuspicious(const CLandsatPixelVector& data1, const LansatData& data2, const Forests3& forest, CloudBitset& suspects1, CloudBitset& suspects2)
{

	for (size_t xy = 0; xy < data1.size(); xy++)
	{
		//size_t xy = y * blockSize.m_x + x;
		if (data1[xy].IsInit())
		{
			size_t fm = get_m(data1[xy], data2[xy]);
			if (fm != NOT_INIT)
			{
				array <CLandsatPixel, 3> p = GetP(data1[xy], data2[xy]);
				size_t xy2 = xy; // ((size_t)index.m_y + y)* extents.m_xSize + index.m_x + x;

				if (m_options.IsTrigged(p, CCloudCleanerIOption::T_PRIMARY, fm))
				{
					suspects1.set(xy2);
				}//if suspect

				if (!suspects2.empty() &&
					m_options.IsTrigged(p, CCloudCleanerIOption::T_SECONDARY, fm))
				{
					suspects2.set(xy2);
				}
			}
		}
	}//xy
//}//y

//m_options.m_xx += (std::min(nbCells, (size_t)blockSize.m_x*blockSize.m_y));
//m_options.UpdateBar();


}

//Get input image reference
void CCloudCleanerI::GetClouds(const CLandsatPixelVector& data1, const LansatData& data2, const Forests3& forests, CloudBitset& suspects1, CloudBitset& suspects2, CloudBitset& clouds)
{
	//	m_options.m_timerProcess.Start();

	for (size_t m = 0; m < 3; m++)
	{
		//forest model, 0: beg, 1: mid, 2: end

		CloudBitset suspectPixel((size_t)data1.size());
		for (size_t xy = 0; xy < data1.size(); xy++)
		{

			if (data1[xy].IsInit())
			{
				size_t fm = get_m(data1[xy], data2[xy]);
				if (fm == m)
				{
					m_options.m_nbPixel++;

					size_t xy2 = xy;// ((size_t)index.m_y + y)* extents.m_xSize + index.m_x + x;
					bool b1 = suspects1.test(xy2);
					bool b2 = !suspects2.empty() ? suspects2.test(xy2) : false;
					if (b1 || b2)
					{
						suspectPixel.set(xy);
						m_options.m_nbPixelDT++;
					}
				}
			}
		}

		if (suspectPixel.count() > 0)
		{
			//forest model, 0: beg, 1: mid, 2: end
			//size_t fm = get_m(data1[xy][0], data2[xy]);// (z == 0) ? 0 : ((z + 1) == nbScenes) ? 2 : 1;

			static const StringVector vars("t1_B1,t1_B2,t1_B3,t1_B4,t1_B5,t1_B6,t1_B7,t2_B1,t2_B2,t2_B3,t2_B4,t2_B5,t2_B6,t2_B7,t3_B1,t3_B2,t3_B3,t3_B4,t3_B5,t3_B6,t3_B7", ",");
			DataShort input;
			input.set_virtual_cols(forests[m]->get_virtual_cols_txt(), forests[m]->get_virtual_cols_name());
			input.resize(suspectPixel.count(), vars);

			size_t cur_xy = 0;
			for (size_t xy = 0; xy < data1.size(); xy++)
			{
				if (suspectPixel.test(xy))
				{
					array <CLandsatPixel, 3> p = GetP(data1[xy], data2[xy]);

					size_t c = 0;
					for (size_t t = 0; t < 3; t++)
					{
						for (size_t b = 0; b < 7; b++)
						{
							bool error = false;
							input.set(c++, cur_xy, p[t][b], error);
						}
					}

					ASSERT(c == 21);
					cur_xy++;
				}//if suspect
			}//x
		//}//y

			input.update_virtual_cols();
			forests[m]->run_predict(&input);

			cur_xy = 0;
			for (size_t xy = 0; xy < data1.size(); xy++)
			{
				//size_t xy = y * blockSize.m_x + x;
				if (suspectPixel.test(xy))
				{
					int RFexit = int(forests[m]->getPredictions().at(0).at(0).at(cur_xy));

					if (RFexit > 100)
					{
						size_t xy2 = xy;// ((size_t)index.m_y + y)* extents.m_xSize + index.m_x + x;
						clouds.set(xy2);
					}//if cloud

					cur_xy++;
				}//if suspect
			}//X

		}//if have suspect
	}

	//m_options.m_xx += (std::min(nbCells, (size_t)blockSize.m_x*blockSize.m_y));
	//m_options.UpdateBar();

	//m_options.m_timerProcess.Stop();

}

void CCloudCleanerI::SetBuffer(const CGeoExtents& extents, CloudBitset& suspects1, CloudBitset& suspects2, CloudBitset& clouds)
{
	if (m_options.m_buffer > 0 || m_options.m_bufferEx > 0)
	{
		//set buffer around cloud
		CloudBitset cloudsCopy = clouds;

		for (size_t y = 0; y < extents.m_ySize; y++)
		{
			for (size_t x = 0; x < extents.m_xSize; x++)
			{
				size_t xy2 = y * extents.m_xSize + x;

				//he suspicious = 
				if (cloudsCopy.test(xy2))
				{
					size_t maxBuffer = max(m_options.m_buffer, m_options.m_bufferEx);
					for (size_t yy = 0; yy < 2 * maxBuffer + 1; yy++)
					{
						for (size_t xx = 0; xx < 2 * maxBuffer + 1; xx++)
						{
							size_t yyy = y + yy - m_options.m_buffer;
							size_t xxx = x + xx - m_options.m_buffer;
							if (yyy < extents.m_ySize && xxx < extents.m_xSize)
							{
								size_t xy3 = yyy * extents.m_xSize + xxx;

								if (xx < (2 * m_options.m_buffer + 1) && yy < (2 * m_options.m_buffer + 1))
								{
									clouds.set(xy3);
								}

								if (xx < (2 * m_options.m_bufferEx + 1) && yy < (2 * m_options.m_bufferEx + 1))
								{
									bool bSus = !suspects2.empty() ? suspects2.test(xy3) : false;
									if (suspects1.test(xy3) || bSus)
										clouds.set(xy3);
								}

							}
						}//for buffer x
					}//for buffer y 
				}//if cloud
			}//x
		}//y
	}
}
//
//void CCloudCleanerI::WriteBlock1(int xBlock, int yBlock, const CBandsHolder& bandHolder, RFCodeData& RFcode, CGDALDatasetEx& DTCodeDS)
//{
//
//#pragma omp critical(BlockIO)
//	{
//
//		m_options.m_timerWrite.Start();
//
//
//		CGeoExtents extents = bandHolder.GetExtents();
//		CGeoSize blockSize = extents.GetBlockSize(xBlock, yBlock);
//		CGeoRectIndex outputRect = extents.GetBlockRect(xBlock, yBlock);
//		assert(bandHolder.GetNbScenes() == bandHolder.GetPeriod().GetNbYears());
//
//
//		ASSERT(outputRect.Width() == blockSize.m_x);
//		ASSERT(outputRect.Height() == blockSize.m_y);
//
//
//		if (m_options.m_bOutputDT)
//		{
//
//			__int16 noData = (__int16)::GetDefaultNoData(GDT_Int16);
//
//			//size_t z1 = m_options.m_scene;
//			for (size_t z = 0; z < DTCodeDS.GetRasterCount(); z++)
//			{
//				ASSERT(RFcode[z].empty() || RFcode[z].size() == outputRect.Width()*outputRect.Height());
//
//				GDALRasterBand *pBand = DTCodeDS.GetRasterBand(z);
//				if (!RFcode.empty())
//					pBand->RasterIO(GF_Write, outputRect.m_x, outputRect.m_y, outputRect.Width(), outputRect.Height(), &(RFcode[z][0]), outputRect.Width(), outputRect.Height(), GDT_Int16, 0, 0);
//				else
//					pBand->RasterIO(GF_Write, outputRect.m_x, outputRect.m_y, outputRect.Width(), outputRect.Height(), &(noData), 1, 1, GDT_Int16, 0, 0);
//			}
//		}
//
//
//	}
//
//	m_options.m_timerWrite.Stop();
//
//}


bool CCloudCleanerI::TouchSuspect1(size_t level, const CGeoExtents& extents, CGeoPointIndex xy, const CloudBitset& suspects1, CloudBitset& suspects2, CloudBitset& treated)
{
	ASSERT(!treated.test(xy.m_y * extents.m_xSize + xy.m_x));

	bool bTouch = false;


	treated.set(xy.m_y * extents.m_xSize + xy.m_x);
	if (suspects1.test(xy.m_y * extents.m_xSize + xy.m_x))
		bTouch = true;

	//on the edge case when suspect pixel touch to cloud 
	for (size_t yy = 0; yy < 3; yy++)
	{
		size_t yyy = xy.m_y + yy - 1;
		if (yyy < extents.m_ySize)
		{
			for (size_t xx = 0; xx < 3; xx++)
			{
				size_t xxx = xy.m_x + xx - 1;
				if (xxx < extents.m_xSize)
				{
					size_t xy2 = yyy * extents.m_xSize + xxx;
					if (!treated.test(xy2) && (suspects1.test(xy2) || suspects2.test(xy2)) && level < 100)
					{
						if (TouchSuspect1(level + 1, extents, CGeoPointIndex((int)xxx, (int)yyy), suspects1, suspects2, treated))
							bTouch = true;
					}//not treated
				}//inside extent
			}//for buffer x
		}//inside extent
	}//for buffer y 

	if (!bTouch)
		suspects2.reset(xy.m_y * extents.m_xSize + xy.m_x);

	return bTouch;
}

void CCloudCleanerI::CleanSuspect2(const CGeoExtents& extents, const CloudBitset& suspects1, CloudBitset& suspects2)
{
	ASSERT(suspects1.size() == suspects2.size());
	CloudBitset treated(suspects1.size());

	for (size_t y = 0; y < extents.m_ySize; y++)
	{
		for (size_t x = 0; x < extents.m_xSize; x++)
		{
			size_t xy = y * extents.m_xSize + x;
			if (!treated.test(xy) && suspects2.test(xy))
			{
				TouchSuspect1(0, extents, CGeoPointIndex((int)x, (int)y), suspects1, suspects2, treated);
			}
		}
	}//for buffer y 
}

//
//void CCloudCleanerI::ProcessBlock2(int xBlock, int yBlock, const CBandsHolder& bandHolder1, const CBandsHolder& bandHolder2, LansatData& data, DebugData& debug, CloudBitset& suspects1, CloudBitset& suspects2, CloudBitset& clouds)
//{
//	//ASSERT(suspects.size() == clouds.size());
//
//	size_t nbScenesProcess = m_options.m_scenes[1] - m_options.m_scenes[0] + 1;
//	size_t nbScenes = bandHolder.GetNbScenes();
//	size_t sceneSize = bandHolder.GetSceneSize();
//	CGeoExtents extents = bandHolder.GetExtents();
//	CGeoRectIndex index = extents.GetBlockRect(xBlock, yBlock);
//	CGeoSize blockSize = extents.GetBlockSize(xBlock, yBlock);
//	size_t nbCells = (size_t)extents.m_xSize*extents.m_ySize;
//
//
//
//	if (bandHolder.IsEmpty())
//	{
//#pragma omp atomic		
//		m_options.m_xx += (std::min(nbCells, (size_t)blockSize.m_x*blockSize.m_y));
//		m_options.UpdateBar();
//
//		return;
//	}
//
//	//allocate process memory and load data
//	LoadData(bandHolder, data);
//	LansatData dataCopy = data;
//
//
//	if (m_options.m_bDebug)
//	{
//		debug.resize(nbScenesProcess*CCloudCleanerIOption::NB_DBUG);
//		for (size_t i = 0; i < debug.size(); i++)
//			debug[i].insert(debug[i].begin(), blockSize.m_x*blockSize.m_y, (__int16)GetDefaultNoData(GDT_Int16));
//	}
//
//	vector<vector<size_t>> replacement;
//	if (m_options.m_bCreateImage && m_options.m_bFillCloud)
//	{
//		replacement.resize(nbScenesProcess);
//		for (size_t i = 0; i < replacement.size(); i++)
//			replacement[i].insert(replacement[i].begin(), blockSize.m_x*blockSize.m_y, NOT_INIT);
//	}
//
//
//	//CloudBitset cloudsCopy = clouds;
//
//
//#pragma omp critical(ProcessBlock)
//	{
//		m_options.m_timerProcess.Start();
//
//
//
//		//if (m_options.m_buffer > 0)
//		//{
//		//	
//		//	//set buffer around cloud
//		//	for (size_t zz = 0; zz < nbScenesProcess; zz++)
//		//	{
//		//		size_t z = m_options.m_scenes[0] + zz;
//		//		for (size_t y = 0; y < blockSize.m_y; y++)
//		//		{
//		//			for (size_t x = 0; x < blockSize.m_x; x++)
//		//			{
//		//				//size_t xy = (size_t)y*blockSize.m_x + x;
//		//				size_t xy2 = ((size_t)index.m_y + y)* extents.m_xSize + index.m_x + x;
//
//		//				//he suspicious = 
//		//				if (clouds[zz].test(xy2))
//		//				{
//		//					for (size_t yy = 0; yy < 2 * m_options.m_buffer + 1; yy++)
//		//					{
//		//						for (size_t xx = 0; xx < 2 * m_options.m_buffer + 1; xx++)
//		//						{
//		//							size_t yyy = index.m_y + y + yy - m_options.m_buffer;
//		//							size_t xxx = index.m_x + x + xx - m_options.m_buffer;
//		//							if (yyy < extents.m_ySize && xxx < extents.m_xSize)
//		//							{
//		//								size_t xy3 = yyy * extents.m_xSize + xxx;
//		//								if(suspects1[zz].test(xy3) || suspects2[zz].test(xy3))
//		//									cloudsCopy[zz].set(xy3);
//		//							}
//		//						}//for buffer x
//		//					}//for buffer y 
//		//				}//if cloud
//		//			}//x
//		//		}//y
//		//	}//zz
//		//}
//
//		//process debug and find replacement pixel 
////no ompMP here
//		for (size_t zz = 0; zz < nbScenesProcess; zz++)
//		{
//			size_t z = m_options.m_scenes[0] + zz;
//			for (size_t y = 0; y < blockSize.m_y; y++)
//			{
//				for (size_t x = 0; x < blockSize.m_x; x++)
//				{
//					size_t xy = (size_t)y*blockSize.m_x + x;
//					size_t xy2 = ((size_t)index.m_y + y)* extents.m_xSize + index.m_x + x;
//
//
//					if (!debug.empty())
//					{
//						array <CLandsatPixel, 3> p = GetP(z, dataCopy[xy]);
//						debug[zz*CCloudCleanerIOption::NB_DBUG + CCloudCleanerIOption::D_DEBUG_ID][xy] = m_options.GetDebugID(p);
//						if (!suspects2.empty())
//						{
//							if (!suspects1[zz].test(xy2) && suspects2[zz].test(xy2))
//								debug[zz*CCloudCleanerIOption::NB_DBUG + CCloudCleanerIOption::D_DEBUG_ID][xy] = m_options.GetDebugID(p, CCloudCleanerIOption::T_SECONDARY);
//						}
//
//						debug[zz*CCloudCleanerIOption::NB_DBUG + CCloudCleanerIOption::D_DEBUG_B1][xy] = m_options.IsB1Trigged(p);
//						debug[zz*CCloudCleanerIOption::NB_DBUG + CCloudCleanerIOption::D_DEBUG_TCB][xy] = m_options.IsTCBTrigged(p);
//						debug[zz*CCloudCleanerIOption::NB_DBUG + CCloudCleanerIOption::D_DEBUG_ZSW][xy] = m_options.IsZSWTrigged(p);
//						debug[zz*CCloudCleanerIOption::NB_DBUG + CCloudCleanerIOption::D_NB_SCENE][xy] = (p[0].IsInit() ? 1 : 0) + (p[1].IsInit() ? 1 : 0) + (p[2].IsInit() ? 1 : 0);
//					}
//
//					//!dataCopy[xy][z].IsInit() || 
//					if (clouds[zz].test(xy2))
//					{
//						size_t z2 = NOT_INIT;
//						for (size_t i = 0; i < dataCopy[xy].size() * 2 && z2 == NOT_INIT; i++)
//						{
//							size_t iz = size_t(z + (int)pow(-1, i)*(i / 2 + 1));
//							if (iz < dataCopy[xy].size() && dataCopy[xy][iz].IsInit())
//							{
//								size_t izz = size_t(zz + (int)pow(-1, i)*(i / 2 + 1));
//
//								bool bReplace = (izz < clouds.size()) ? !(clouds[izz].test(xy2) && suspects1[izz].test(xy2)) : true;
//								//bool bReplace = (izz < clouds.size()) ? !clouds[izz].test(xy2) : true;
//								if (bReplace)
//									z2 = iz;
//							}
//						}
//
//						//if z2 is not init
//						/*if (z2 == NOT_INIT)
//						{
//							__int32 minVal = 32767;
//							for (size_t i = 0; i < dataCopy[xy].size() * 2; i++)
//							{
//								size_t iz = size_t(z + (int)pow(-1, i)*(i / 2 + 1));
//								if (iz < dataCopy[xy].size() && dataCopy[xy][iz].IsInit())
//								{
//									size_t izz = size_t(zz + (int)pow(-1, i)*(i / 2 + 1));
//									array <CLandsatPixel, 3> p = GetP(izz, dataCopy[xy]);
//									if (m_options.GetTrigger(p) < minVal)
//									{
//										minVal = m_options.GetTrigger(p);
//										z2 = iz;
//									}
//								}
//							}
//						}
//*/
//
//
//						if (!debug.empty())
//						{
//							debug[zz*CCloudCleanerIOption::NB_DBUG + CCloudCleanerIOption::D_SCENE_USED][xy] = (z2 != NOT_INIT) ? (__int16)(z2 - z) : -999;
//						}
//
//						data[xy][z].Reset();
//
//						if (!replacement.empty())
//							replacement[zz][xy] = z2;
//					}
//					m_options.m_xx++;
//				}//x
//			}//y
//			m_options.UpdateBar();
//		}// z
//
//		//replace cloud by valid pixel for all x and y 
//		for (size_t zz = 0; zz < replacement.size(); zz++)
//		{
//			size_t z = m_options.m_scenes[0] + zz;
//			for (size_t xy = 0; xy < replacement[zz].size(); xy++)
//			{
//				if (replacement[zz][xy] != NOT_INIT)
//				{
//					data[xy][z] = dataCopy[xy][replacement[zz][xy]];
//				}
//			}//for xy
//		}//z
//
//
//		m_options.m_timerProcess.Stop();
//	}//critical
//}

//
//void CCloudCleanerI::WriteBlock2(int xBlock, int yBlock, const CBandsHolder& bandHolder, const LansatData& data, DebugData& debug, CGDALDatasetEx& outputDS, CGDALDatasetEx& debugDS)
//{
//
//#pragma omp critical(BlockIO)
//	{
//
//		m_options.m_timerWrite.Start();
//
//
//		CGeoExtents extents = bandHolder.GetExtents();
//		CGeoSize blockSize = extents.GetBlockSize(xBlock, yBlock);
//		CGeoRectIndex outputRect = extents.GetBlockRect(xBlock, yBlock);
//		assert(bandHolder.GetNbScenes() == bandHolder.GetPeriod().GetNbYears());
//
//
//		ASSERT(outputRect.Width() == blockSize.m_x);
//		ASSERT(outputRect.Height() == blockSize.m_y);
//
//		if (m_options.m_bCreateImage)
//		{
//			ASSERT(outputDS.GetRasterCount() % SCENES_SIZE == 0);
//
//			__int16 noData = (__int16)outputDS.GetNoData(0);
//			vector<__int16> tmp(blockSize.m_x*blockSize.m_y, noData);
//
//			//size_t z1 = m_options.m_scene;
//			for (size_t bb = 0; bb < outputDS.GetRasterCount(); bb++)
//			{
//				GDALRasterBand *pBand = outputDS.GetRasterBand(bb);
//
//				if (!data.empty())
//				{
//					ASSERT(data.size() == blockSize.m_x*blockSize.m_y);
//
//					size_t z = m_options.m_scenes[0] + bb / SCENES_SIZE;
//					size_t b = bb % SCENES_SIZE;
//					for (int y = 0; y < blockSize.m_y; y++)
//					{
//						for (int x = 0; x < blockSize.m_x; x++)
//						{
//							int xy = int(y*blockSize.m_x + x);
//							tmp[xy] = data[xy][z][b];
//						}//x
//					}//y
//
//					pBand->RasterIO(GF_Write, outputRect.m_x, outputRect.m_y, outputRect.Width(), outputRect.Height(), &(tmp[0]), outputRect.Width(), outputRect.Height(), GDT_Int16, 0, 0);
//				}
//				else
//				{
//					pBand->RasterIO(GF_Write, outputRect.m_x, outputRect.m_y, outputRect.Width(), outputRect.Height(), &(noData), 1, 1, GDT_Int16, 0, 0);
//				}
//
//			}//for all debug bands
//		}//if create image
//
//		if (m_options.m_bDebug)
//		{
//			__int16 noData = (__int16)::GetDefaultNoData(GDT_Int16);
//
//			for (size_t b = 0; b < debugDS.GetRasterCount(); b++)
//			{
//				GDALRasterBand *pBand = debugDS.GetRasterBand(b);
//				if (!debug.empty() && !debug[b].empty())
//					pBand->RasterIO(GF_Write, outputRect.m_x, outputRect.m_y, outputRect.Width(), outputRect.Height(), &(debug[b][0]), outputRect.Width(), outputRect.Height(), GDT_Int16, 0, 0);
//				else
//					pBand->RasterIO(GF_Write, outputRect.m_x, outputRect.m_y, outputRect.Width(), outputRect.Height(), &(noData), 1, 1, GDT_Int16, 0, 0);
//			}//for all debug variable
//		}//debug
//	}//critical
//}

void CCloudCleanerI::CloseAll(CGDALDatasetEx& inputDS, CGDALDatasetEx& refDS, CGDALDatasetEx& maskDS)
{
	if (!m_options.m_bQuiet)
		_tprintf("\nClose all files...\n");

	inputDS.Close();
	refDS.Close();
	maskDS.Close();

	/*
		m_options.m_timerWrite.Start();

		outputDS.Close(m_options);
		DTCodeDS.Close(m_options);
		debugDS.Close(m_options);


		m_options.m_timerWrite.Stop();

		if (!m_options.m_bQuiet)
		{
			double percent = m_options.m_nbPixel > 0 ? (double)m_options.m_nbPixelDT / m_options.m_nbPixel * 100 : 0;

			_tprintf("\n");
			_tprintf("Percentage of pixel treated by Ranger: %0.3lf %%\n\n", percent);
		}
	*/
	m_options.PrintTime();
}

void CCloudCleanerI::LoadData(const CBandsHolder& bandHolder, LansatData& data)
{
	CLandsatWindow window = bandHolder.GetWindow();
	size_t nbScenes = bandHolder.GetNbScenes();

	//size_t nbScenes = m_options.m_maxScene * 2 + 1;

	CGeoSize blockSize = window.GetGeoSize();
	data.resize(blockSize.m_x*blockSize.m_y);
	for (int x = 0; x < blockSize.m_x; x++)
	{
		for (int y = 0; y < blockSize.m_y; y++)
		{
			data[y*blockSize.m_x + x].resize(nbScenes);
			for (size_t z = 0; z < nbScenes; z++)
			{
				data[y*blockSize.m_x + x][z] = window.GetPixel(z, x, y);
			}
		}
	}
}

void CCloudCleanerI::LoadData(size_t z, const CBandsHolder& bandHolder, CLandsatPixelVector& data)
{
	CLandsatWindow window = bandHolder.GetWindow();

	CGeoSize blockSize = window.GetGeoSize();
	data.resize(blockSize.m_x*blockSize.m_y);
	for (int x = 0; x < blockSize.m_x; x++)
	{
		for (int y = 0; y < blockSize.m_y; y++)
		{
			data[y*blockSize.m_x + x] = window.GetPixel(z, x, y);
		}
	}
}




__int32 CCloudCleanerIOption::GetB1Trigger(std::array <CLandsatPixel, 3>& p, size_t t, size_t fm)
{
	size_t c0 = (fm == 0) ? 1 : 0;
	size_t c2 = (fm == 2) ? 1 : 2;

	if (!p[fm].IsInit())
		return 32767;

	if (!p[c0].IsInit() && !p[c2].IsInit())
		return 32767;

	__int32 t1 = p[c0].IsInit() ? max(0, m_B1threshold[t] - (p[c0][Landsat::B1] - p[fm][Landsat::B1])) : 0;
	__int32 t2 = p[c2].IsInit() ? max(0, m_B1threshold[t] - (p[c2][Landsat::B1] - p[fm][Landsat::B1])) : 0;
	__int32 t3 = (p[c0].IsInit() ? 1 : 0) + (p[c2].IsInit() ? 1 : 0);

	return (t1 + t2) / t3;
}

__int32 CCloudCleanerIOption::GetTCBTrigger(std::array <CLandsatPixel, 3>& p, size_t t, size_t fm)
{
	size_t c0 = (fm == 0) ? 1 : 0;
	size_t c2 = (fm == 2) ? 1 : 2;

	if (!p[fm].IsInit())
		return 32767;

	if (!p[c0].IsInit() && !p[c2].IsInit())
		return 32767;

	__int32 t1 = p[c0].IsInit() ? max(0, (p[c0][Landsat::I_TCB] - p[fm][Landsat::I_TCB]) - m_TCBthreshold[t]) : 0;
	__int32 t2 = p[c2].IsInit() ? max(0, (p[c2][Landsat::I_TCB] - p[fm][Landsat::I_TCB]) - m_TCBthreshold[t]) : 0;
	__int32 t3 = (p[c0].IsInit() ? 1 : 0) + (p[c2].IsInit() ? 1 : 0);


	return (t1 + t2) / t3;
}

__int32 CCloudCleanerIOption::GetZSWTrigger(std::array <CLandsatPixel, 3>& p, size_t t, size_t fm)
{
	size_t c0 = (fm == 0) ? 1 : 0;
	size_t c2 = (fm == 2) ? 1 : 2;

	if (!p[fm].IsInit())
		return 32767;

	if (!p[c0].IsInit() && !p[c2].IsInit())
		return 32767;

	__int32 t1 = p[c0].IsInit() ? max(0, (p[c0][Landsat::I_ZSW] - p[fm][Landsat::I_ZSW]) - m_ZSWthreshold[t]) : 0;
	__int32 t2 = p[c2].IsInit() ? max(0, (p[c2][Landsat::I_ZSW] - p[fm][Landsat::I_ZSW]) - m_ZSWthreshold[t]) : 0;
	__int32 t3 = (p[c0].IsInit() ? 1 : 0) + (p[c2].IsInit() ? 1 : 0);

	return (t1 + t2) / t3;
}



